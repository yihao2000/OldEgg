package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"
	"os"
	"time"

	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/yihao2000/gqlgen-todos/config"
	"github.com/yihao2000/gqlgen-todos/graph/model"
	"github.com/yihao2000/gqlgen-todos/service"
)

// Checkout is the resolver for the checkout field.
func (r *mutationResolver) Checkout(ctx context.Context, shippingID string, paymentTypeID string, addressID string) (*model.TransactionHeader, error) {
	db := config.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Error, token gaada",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	var carts []*model.Cart
	err := db.Where("user_id = ?", userID).Find(&carts).Error
	if err != nil || carts == nil {
		return nil, &gqlerror.Error{
			Message: "Error, cart gaada",
		}
	}

	var validTo string
	if os.Getenv("MIN_DATE") != "" {
		validTo = os.Getenv("MIN_DATE")
	} else {
		validTo = "9999-12-31 23:59:59.999999"
	}

	for _, c := range carts {
		product := new(model.Product)
		if err := db.First(product, "id = ? AND (valid_to IS NULL OR valid_to = '"+validTo+"')", c.ProductID).Error; err != nil {
			return nil, err
		}

		if c.Quantity > product.Quantity {
			return nil, &gqlerror.Error{
				Message: "Error, Stock Gacukup !",
			}
		}

	}

	generatedInvoice := uuid.NewString()
	header := &model.TransactionHeader{
		ID:              uuid.NewString(),
		TransactionDate: time.Now(),
		UserID:          userID,
		ShippingID:      shippingID,
		PaymentTypeID:   paymentTypeID,
		Status:          "Open",
		AddressID:       addressID,
		Invoice:         string(generatedInvoice[0:7]),
	}

	err = db.Create(header).Error

	if err != nil {
		return header, &gqlerror.Error{
			Message: "Error, create header",
		}
	}

	for _, c := range carts {
		detail := &model.TransactionDetail{
			TransactionHeaderID: header.ID,
			ProductID:           c.ProductID,
			Quantity:            c.Quantity,
		}

		product := new(model.Product)
		if err := db.First(product, "id = ? AND (valid_to IS NULL OR valid_to = '"+validTo+"')", c.ProductID).Error; err != nil {
			return nil, err
		}

		product.Quantity -= c.Quantity

		if err := db.Save(product).Error; err != nil {
			return nil, err
		}
		err = db.Create(detail).Error
		if err != nil {
			return header, &gqlerror.Error{
				Message: "Error, create detail",
			}
		}

		err = db.Delete(c).Error
		if err != nil {
			return header, &gqlerror.Error{
				Message: "Error, delete cart",
			}
		}
	}

	return header, nil
}

// CreateVoucher is the resolver for the createVoucher field.
func (r *mutationResolver) CreateVoucher(ctx context.Context, balance float64) (*model.Voucher, error) {
	db := config.GetDB()

	voucher := model.Voucher{
		ID:          uuid.NewString(),
		Balance:     balance,
		DateCreated: time.Now(),
	}

	return &voucher, db.Model(voucher).Create(&voucher).Error
}

// UpdateVoucher is the resolver for the updateVoucher field.
func (r *mutationResolver) UpdateVoucher(ctx context.Context, voucherID string) (*model.Voucher, error) {
	db := config.GetDB()
	voucher := new(model.Voucher)

	err := db.First(voucher, "id = ?", voucherID).Error
	if err != nil {
		return voucher, err
	}

	if voucher.DateUsed != nil {
		return nil, &gqlerror.Error{
			Message: "Voucher has already been used!",
		}
	}
	// voucher.DateUsed=time.Now()
	t := time.Now()
	voucher.DateUsed = &t

	db.Save(voucher)

	return voucher, nil
}

// Shipping is the resolver for the shipping field.
func (r *queryResolver) Shipping(ctx context.Context, id string) (*model.Shipping, error) {
	panic(fmt.Errorf("not implemented: Shipping - shipping"))
}

// Shippings is the resolver for the shippings field.
func (r *queryResolver) Shippings(ctx context.Context) ([]*model.Shipping, error) {
	db := config.GetDB()
	var models []*model.Shipping
	return models, db.Find(&models).Error
}

// PaymentType is the resolver for the paymentType field.
func (r *queryResolver) PaymentType(ctx context.Context, id string) (*model.PaymentType, error) {
	panic(fmt.Errorf("not implemented: PaymentType - paymentType"))
}

// PaymentTypes is the resolver for the paymentTypes field.
func (r *queryResolver) PaymentTypes(ctx context.Context) ([]*model.PaymentType, error) {
	db := config.GetDB()
	var models []*model.PaymentType
	return models, db.Find(&models).Error
}

// TransactionHeaders is the resolver for the transactionHeaders field.
func (r *queryResolver) TransactionHeaders(ctx context.Context) ([]*model.TransactionHeader, error) {
	panic(fmt.Errorf("not implemented: TransactionHeaders - transactionHeaders"))
}

// UserTransactionHeaders is the resolver for the userTransactionHeaders field.
func (r *queryResolver) UserTransactionHeaders(ctx context.Context, ordersWithin *int, ordersType *string, search *string) ([]*model.TransactionHeader, error) {
	db := config.GetDB()

	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Error, token gaada",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	var transactionHeaders []*model.TransactionHeader

	temp := db.Where("user_id = ?", userID)

	if ordersWithin != nil && *ordersWithin != 0 {

		startDate := time.Now().AddDate(0, 0, -*ordersWithin).Format("2006-01-02")
		temp = temp.Where("transaction_date >= ?", startDate)
	}

	if ordersType != nil && *ordersType != "All" {
		temp = temp.Where("status LIKE ?", ordersType)
	}

	if search != nil {
		// temp = temp.Joins("JOIN transaction_details ON transaction_headers.id = transaction_details.transaction_header_id JOIN products ON transaction_details.product_id = products.id").
		// 	Where("transaction_headers.id LIKE ? OR transaction_headers.invoice LIKE ? OR products.name LIKE ?", "%"+*search+"%", "%"+*search+"%", "%"+*search+"%")

		temp = temp.Where("invoice LIKE ? OR id LIKE ?", "%"+*search+"%", "%"+*search+"%")
	}

	return transactionHeaders, temp.Find(&transactionHeaders).Error
}

// TransactionHeader is the resolver for the transactionHeader field.
func (r *transactionDetailResolver) TransactionHeader(ctx context.Context, obj *model.TransactionDetail) (*model.TransactionHeader, error) {
	panic(fmt.Errorf("not implemented: TransactionHeader - transactionHeader"))
}

// Product is the resolver for the product field.
func (r *transactionDetailResolver) Product(ctx context.Context, obj *model.TransactionDetail) (*model.Product, error) {
	db := config.GetDB()
	model := new(model.Product)

	return model, db.First(model, "id = ?", obj.ProductID).Error
}

// User is the resolver for the user field.
func (r *transactionHeaderResolver) User(ctx context.Context, obj *model.TransactionHeader) (*model.User, error) {
	panic(fmt.Errorf("not implemented: User - user"))
}

// Shipping is the resolver for the shipping field.
func (r *transactionHeaderResolver) Shipping(ctx context.Context, obj *model.TransactionHeader) (*model.Shipping, error) {
	db := config.GetDB()
	model := new(model.Shipping)

	return model, db.First(model, "id = ?", obj.ShippingID).Error
}

// PaymentType is the resolver for the paymentType field.
func (r *transactionHeaderResolver) PaymentType(ctx context.Context, obj *model.TransactionHeader) (*model.PaymentType, error) {
	db := config.GetDB()
	model := new(model.PaymentType)

	return model, db.First(model, "id = ?", obj.PaymentTypeID).Error
}

// Address is the resolver for the address field.
func (r *transactionHeaderResolver) Address(ctx context.Context, obj *model.TransactionHeader) (*model.Address, error) {
	db := config.GetDB()
	model := new(model.Address)

	return model, db.First(model, "id = ?", obj.AddressID).Error
}

// TransactionDetails is the resolver for the transactionDetails field.
func (r *transactionHeaderResolver) TransactionDetails(ctx context.Context, obj *model.TransactionHeader) ([]*model.TransactionDetail, error) {
	db := config.GetDB()
	var models []*model.TransactionDetail
	return models, db.Where("transaction_header_id = ?", obj.ID).Find(&models).Error
}

// TransactionDetail returns TransactionDetailResolver implementation.
func (r *Resolver) TransactionDetail() TransactionDetailResolver {
	return &transactionDetailResolver{r}
}

// TransactionHeader returns TransactionHeaderResolver implementation.
func (r *Resolver) TransactionHeader() TransactionHeaderResolver {
	return &transactionHeaderResolver{r}
}

type transactionDetailResolver struct{ *Resolver }
type transactionHeaderResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *mutationResolver) CreateNewVoucher(ctx context.Context, balance float64) (*model.Voucher, error) {
	panic(fmt.Errorf("not implemented: CreateNewVoucher - createNewVoucher"))
}
func (r *transactionHeaderResolver) Invoice(ctx context.Context, obj *model.TransactionHeader) (string, error) {
	panic(fmt.Errorf("not implemented: Invoice - invoice"))
}
